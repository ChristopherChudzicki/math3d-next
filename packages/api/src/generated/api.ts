/* tslint:disable */
/* eslint-disable */
/**
 * Math3d API
 * Math3d API
 *
 * The version of the OpenAPI document: 0.0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from "./base";

/**
 *
 * @export
 * @interface Activation
 */
export interface Activation {
  /**
   *
   * @type {string}
   * @memberof Activation
   */
  uid: string;
  /**
   *
   * @type {string}
   * @memberof Activation
   */
  token: string;
}
/**
 *
 * @export
 * @interface ActivationRequest
 */
export interface ActivationRequest {
  /**
   *
   * @type {string}
   * @memberof ActivationRequest
   */
  uid: string;
  /**
   *
   * @type {string}
   * @memberof ActivationRequest
   */
  token: string;
}
/**
 *
 * @export
 * @interface MiniScene
 */
export interface MiniScene {
  /**
   *
   * @type {string}
   * @memberof MiniScene
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof MiniScene
   */
  key?: string;
  /**
   *
   * @type {number}
   * @memberof MiniScene
   */
  author?: number | null;
  /**
   *
   * @type {string}
   * @memberof MiniScene
   */
  createdDate: string;
  /**
   *
   * @type {string}
   * @memberof MiniScene
   */
  modifiedDate: string;
}
/**
 *
 * @export
 * @interface PaginatedMiniSceneList
 */
export interface PaginatedMiniSceneList {
  /**
   *
   * @type {number}
   * @memberof PaginatedMiniSceneList
   */
  count?: number;
  /**
   *
   * @type {string}
   * @memberof PaginatedMiniSceneList
   */
  next?: string | null;
  /**
   *
   * @type {string}
   * @memberof PaginatedMiniSceneList
   */
  previous?: string | null;
  /**
   *
   * @type {Array<MiniScene>}
   * @memberof PaginatedMiniSceneList
   */
  results?: Array<MiniScene>;
}
/**
 *
 * @export
 * @interface PaginatedUserList
 */
export interface PaginatedUserList {
  /**
   *
   * @type {number}
   * @memberof PaginatedUserList
   */
  count?: number;
  /**
   *
   * @type {string}
   * @memberof PaginatedUserList
   */
  next?: string | null;
  /**
   *
   * @type {string}
   * @memberof PaginatedUserList
   */
  previous?: string | null;
  /**
   *
   * @type {Array<User>}
   * @memberof PaginatedUserList
   */
  results?: Array<User>;
}
/**
 *
 * @export
 * @interface PasswordResetConfirmRetype
 */
export interface PasswordResetConfirmRetype {
  /**
   *
   * @type {string}
   * @memberof PasswordResetConfirmRetype
   */
  uid: string;
  /**
   *
   * @type {string}
   * @memberof PasswordResetConfirmRetype
   */
  token: string;
  /**
   *
   * @type {string}
   * @memberof PasswordResetConfirmRetype
   */
  new_password: string;
  /**
   *
   * @type {string}
   * @memberof PasswordResetConfirmRetype
   */
  re_new_password: string;
}
/**
 *
 * @export
 * @interface PasswordResetConfirmRetypeRequest
 */
export interface PasswordResetConfirmRetypeRequest {
  /**
   *
   * @type {string}
   * @memberof PasswordResetConfirmRetypeRequest
   */
  uid: string;
  /**
   *
   * @type {string}
   * @memberof PasswordResetConfirmRetypeRequest
   */
  token: string;
  /**
   *
   * @type {string}
   * @memberof PasswordResetConfirmRetypeRequest
   */
  new_password: string;
  /**
   *
   * @type {string}
   * @memberof PasswordResetConfirmRetypeRequest
   */
  re_new_password: string;
}
/**
 *
 * @export
 * @interface PatchedSceneRequest
 */
export interface PatchedSceneRequest {
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof PatchedSceneRequest
   */
  items?: { [key: string]: any };
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof PatchedSceneRequest
   */
  itemOrder?: { [key: string]: any };
  /**
   *
   * @type {string}
   * @memberof PatchedSceneRequest
   */
  title?: string;
}
/**
 *
 * @export
 * @interface PatchedUserRequest
 */
export interface PatchedUserRequest {
  /**
   *
   * @type {string}
   * @memberof PatchedUserRequest
   */
  public_nickname?: string;
}
/**
 *
 * @export
 * @interface Scene
 */
export interface Scene {
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof Scene
   */
  items: { [key: string]: any };
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof Scene
   */
  itemOrder: { [key: string]: any };
  /**
   *
   * @type {string}
   * @memberof Scene
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof Scene
   */
  key: string;
  /**
   *
   * @type {string}
   * @memberof Scene
   */
  createdDate: string;
  /**
   *
   * @type {string}
   * @memberof Scene
   */
  modifiedDate: string;
}
/**
 *
 * @export
 * @interface SceneRequest
 */
export interface SceneRequest {
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof SceneRequest
   */
  items: { [key: string]: any };
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof SceneRequest
   */
  itemOrder: { [key: string]: any };
  /**
   *
   * @type {string}
   * @memberof SceneRequest
   */
  title?: string;
}
/**
 *
 * @export
 * @interface SendEmailReset
 */
export interface SendEmailReset {
  /**
   *
   * @type {string}
   * @memberof SendEmailReset
   */
  email: string;
}
/**
 *
 * @export
 * @interface SendEmailResetRequest
 */
export interface SendEmailResetRequest {
  /**
   *
   * @type {string}
   * @memberof SendEmailResetRequest
   */
  email: string;
}
/**
 *
 * @export
 * @interface SetPasswordRetype
 */
export interface SetPasswordRetype {
  /**
   *
   * @type {string}
   * @memberof SetPasswordRetype
   */
  new_password: string;
  /**
   *
   * @type {string}
   * @memberof SetPasswordRetype
   */
  re_new_password: string;
  /**
   *
   * @type {string}
   * @memberof SetPasswordRetype
   */
  current_password: string;
}
/**
 *
 * @export
 * @interface SetPasswordRetypeRequest
 */
export interface SetPasswordRetypeRequest {
  /**
   *
   * @type {string}
   * @memberof SetPasswordRetypeRequest
   */
  new_password: string;
  /**
   *
   * @type {string}
   * @memberof SetPasswordRetypeRequest
   */
  re_new_password: string;
  /**
   *
   * @type {string}
   * @memberof SetPasswordRetypeRequest
   */
  current_password: string;
}
/**
 *
 * @export
 * @interface TokenCreate
 */
export interface TokenCreate {
  /**
   *
   * @type {string}
   * @memberof TokenCreate
   */
  password?: string;
  /**
   *
   * @type {string}
   * @memberof TokenCreate
   */
  email?: string;
}
/**
 *
 * @export
 * @interface TokenCreateRequest
 */
export interface TokenCreateRequest {
  /**
   *
   * @type {string}
   * @memberof TokenCreateRequest
   */
  password?: string;
  /**
   *
   * @type {string}
   * @memberof TokenCreateRequest
   */
  email?: string;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {number}
   * @memberof User
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof User
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  public_nickname: string;
}
/**
 *
 * @export
 * @interface UserCreatePasswordRetypeRequest
 */
export interface UserCreatePasswordRetypeRequest {
  /**
   *
   * @type {string}
   * @memberof UserCreatePasswordRetypeRequest
   */
  public_nickname: string;
  /**
   *
   * @type {string}
   * @memberof UserCreatePasswordRetypeRequest
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof UserCreatePasswordRetypeRequest
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof UserCreatePasswordRetypeRequest
   */
  re_password: string;
}
/**
 *
 * @export
 * @interface UserRequest
 */
export interface UserRequest {
  /**
   *
   * @type {string}
   * @memberof UserRequest
   */
  public_nickname: string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Use this endpoint to obtain user authentication token.
     * @param {TokenCreateRequest} [TokenCreateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authTokenLoginCreate: async (
      TokenCreateRequest?: TokenCreateRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v0/auth/token/login/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication tokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "Authorization",
        configuration,
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        TokenCreateRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Use this endpoint to logout user (remove user authentication token).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authTokenLogoutCreate: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v0/auth/token/logout/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication tokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "Authorization",
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {ActivationRequest} ActivationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersActivationCreate: async (
      ActivationRequest: ActivationRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'ActivationRequest' is not null or undefined
      assertParamExists(
        "authUsersActivationCreate",
        "ActivationRequest",
        ActivationRequest,
      );
      const localVarPath = `/v0/auth/users/activation/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication tokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "Authorization",
        configuration,
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        ActivationRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {UserCreatePasswordRetypeRequest} UserCreatePasswordRetypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersCreate: async (
      UserCreatePasswordRetypeRequest: UserCreatePasswordRetypeRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'UserCreatePasswordRetypeRequest' is not null or undefined
      assertParamExists(
        "authUsersCreate",
        "UserCreatePasswordRetypeRequest",
        UserCreatePasswordRetypeRequest,
      );
      const localVarPath = `/v0/auth/users/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication tokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "Authorization",
        configuration,
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        UserCreatePasswordRetypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {number} id A unique integer value identifying this User.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersDestroy: async (
      id: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("authUsersDestroy", "id", id);
      const localVarPath = `/v0/auth/users/{id}/`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication tokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "Authorization",
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersList: async (
      limit?: number,
      offset?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v0/auth/users/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication tokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "Authorization",
        configuration,
      );

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersMeDestroy: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v0/auth/users/me/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication tokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "Authorization",
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {PatchedUserRequest} [PatchedUserRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersMePartialUpdate: async (
      PatchedUserRequest?: PatchedUserRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v0/auth/users/me/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication tokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "Authorization",
        configuration,
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        PatchedUserRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersMeRetrieve: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v0/auth/users/me/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication tokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "Authorization",
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {UserRequest} UserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersMeUpdate: async (
      UserRequest: UserRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'UserRequest' is not null or undefined
      assertParamExists("authUsersMeUpdate", "UserRequest", UserRequest);
      const localVarPath = `/v0/auth/users/me/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication tokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "Authorization",
        configuration,
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        UserRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {number} id A unique integer value identifying this User.
     * @param {PatchedUserRequest} [PatchedUserRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersPartialUpdate: async (
      id: number,
      PatchedUserRequest?: PatchedUserRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("authUsersPartialUpdate", "id", id);
      const localVarPath = `/v0/auth/users/{id}/`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication tokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "Authorization",
        configuration,
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        PatchedUserRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {SendEmailResetRequest} SendEmailResetRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersResendActivationCreate: async (
      SendEmailResetRequest: SendEmailResetRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'SendEmailResetRequest' is not null or undefined
      assertParamExists(
        "authUsersResendActivationCreate",
        "SendEmailResetRequest",
        SendEmailResetRequest,
      );
      const localVarPath = `/v0/auth/users/resend_activation/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication tokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "Authorization",
        configuration,
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        SendEmailResetRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {PasswordResetConfirmRetypeRequest} PasswordResetConfirmRetypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersResetPasswordConfirmCreate: async (
      PasswordResetConfirmRetypeRequest: PasswordResetConfirmRetypeRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'PasswordResetConfirmRetypeRequest' is not null or undefined
      assertParamExists(
        "authUsersResetPasswordConfirmCreate",
        "PasswordResetConfirmRetypeRequest",
        PasswordResetConfirmRetypeRequest,
      );
      const localVarPath = `/v0/auth/users/reset_password_confirm/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication tokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "Authorization",
        configuration,
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        PasswordResetConfirmRetypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {SendEmailResetRequest} SendEmailResetRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersResetPasswordCreate: async (
      SendEmailResetRequest: SendEmailResetRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'SendEmailResetRequest' is not null or undefined
      assertParamExists(
        "authUsersResetPasswordCreate",
        "SendEmailResetRequest",
        SendEmailResetRequest,
      );
      const localVarPath = `/v0/auth/users/reset_password/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication tokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "Authorization",
        configuration,
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        SendEmailResetRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {number} id A unique integer value identifying this User.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersRetrieve: async (
      id: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("authUsersRetrieve", "id", id);
      const localVarPath = `/v0/auth/users/{id}/`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication tokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "Authorization",
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {SetPasswordRetypeRequest} SetPasswordRetypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersSetPasswordCreate: async (
      SetPasswordRetypeRequest: SetPasswordRetypeRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'SetPasswordRetypeRequest' is not null or undefined
      assertParamExists(
        "authUsersSetPasswordCreate",
        "SetPasswordRetypeRequest",
        SetPasswordRetypeRequest,
      );
      const localVarPath = `/v0/auth/users/set_password/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication tokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "Authorization",
        configuration,
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        SetPasswordRetypeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {number} id A unique integer value identifying this User.
     * @param {UserRequest} UserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersUpdate: async (
      id: number,
      UserRequest: UserRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("authUsersUpdate", "id", id);
      // verify required parameter 'UserRequest' is not null or undefined
      assertParamExists("authUsersUpdate", "UserRequest", UserRequest);
      const localVarPath = `/v0/auth/users/{id}/`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication tokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "Authorization",
        configuration,
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        UserRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration);
  return {
    /**
     * Use this endpoint to obtain user authentication token.
     * @param {TokenCreateRequest} [TokenCreateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authTokenLoginCreate(
      TokenCreateRequest?: TokenCreateRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenCreate>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.authTokenLoginCreate(
          TokenCreateRequest,
          options,
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["AuthApi.authTokenLoginCreate"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     * Use this endpoint to logout user (remove user authentication token).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authTokenLogoutCreate(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.authTokenLogoutCreate(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["AuthApi.authTokenLogoutCreate"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {ActivationRequest} ActivationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authUsersActivationCreate(
      ActivationRequest: ActivationRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Activation>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.authUsersActivationCreate(
          ActivationRequest,
          options,
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["AuthApi.authUsersActivationCreate"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {UserCreatePasswordRetypeRequest} UserCreatePasswordRetypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authUsersCreate(
      UserCreatePasswordRetypeRequest: UserCreatePasswordRetypeRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authUsersCreate(
        UserCreatePasswordRetypeRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["AuthApi.authUsersCreate"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {number} id A unique integer value identifying this User.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authUsersDestroy(
      id: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.authUsersDestroy(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["AuthApi.authUsersDestroy"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authUsersList(
      limit?: number,
      offset?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PaginatedUserList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authUsersList(
        limit,
        offset,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["AuthApi.authUsersList"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authUsersMeDestroy(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.authUsersMeDestroy(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["AuthApi.authUsersMeDestroy"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {PatchedUserRequest} [PatchedUserRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authUsersMePartialUpdate(
      PatchedUserRequest?: PatchedUserRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.authUsersMePartialUpdate(
          PatchedUserRequest,
          options,
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["AuthApi.authUsersMePartialUpdate"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authUsersMeRetrieve(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.authUsersMeRetrieve(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["AuthApi.authUsersMeRetrieve"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {UserRequest} UserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authUsersMeUpdate(
      UserRequest: UserRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.authUsersMeUpdate(UserRequest, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["AuthApi.authUsersMeUpdate"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {number} id A unique integer value identifying this User.
     * @param {PatchedUserRequest} [PatchedUserRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authUsersPartialUpdate(
      id: number,
      PatchedUserRequest?: PatchedUserRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.authUsersPartialUpdate(
          id,
          PatchedUserRequest,
          options,
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["AuthApi.authUsersPartialUpdate"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {SendEmailResetRequest} SendEmailResetRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authUsersResendActivationCreate(
      SendEmailResetRequest: SendEmailResetRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendEmailReset>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.authUsersResendActivationCreate(
          SendEmailResetRequest,
          options,
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["AuthApi.authUsersResendActivationCreate"]?.[index]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {PasswordResetConfirmRetypeRequest} PasswordResetConfirmRetypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authUsersResetPasswordConfirmCreate(
      PasswordResetConfirmRetypeRequest: PasswordResetConfirmRetypeRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PasswordResetConfirmRetype>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.authUsersResetPasswordConfirmCreate(
          PasswordResetConfirmRetypeRequest,
          options,
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["AuthApi.authUsersResetPasswordConfirmCreate"]?.[
          index
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {SendEmailResetRequest} SendEmailResetRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authUsersResetPasswordCreate(
      SendEmailResetRequest: SendEmailResetRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendEmailReset>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.authUsersResetPasswordCreate(
          SendEmailResetRequest,
          options,
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["AuthApi.authUsersResetPasswordCreate"]?.[index]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {number} id A unique integer value identifying this User.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authUsersRetrieve(
      id: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.authUsersRetrieve(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["AuthApi.authUsersRetrieve"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {SetPasswordRetypeRequest} SetPasswordRetypeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authUsersSetPasswordCreate(
      SetPasswordRetypeRequest: SetPasswordRetypeRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SetPasswordRetype>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.authUsersSetPasswordCreate(
          SetPasswordRetypeRequest,
          options,
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["AuthApi.authUsersSetPasswordCreate"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {number} id A unique integer value identifying this User.
     * @param {UserRequest} UserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authUsersUpdate(
      id: number,
      UserRequest: UserRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authUsersUpdate(
        id,
        UserRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["AuthApi.authUsersUpdate"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AuthApiFp(configuration);
  return {
    /**
     * Use this endpoint to obtain user authentication token.
     * @param {AuthApiAuthTokenLoginCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authTokenLoginCreate(
      requestParameters: AuthApiAuthTokenLoginCreateRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<TokenCreate> {
      return localVarFp
        .authTokenLoginCreate(requestParameters.TokenCreateRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Use this endpoint to logout user (remove user authentication token).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authTokenLogoutCreate(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp
        .authTokenLogoutCreate(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {AuthApiAuthUsersActivationCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersActivationCreate(
      requestParameters: AuthApiAuthUsersActivationCreateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Activation> {
      return localVarFp
        .authUsersActivationCreate(requestParameters.ActivationRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {AuthApiAuthUsersCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersCreate(
      requestParameters: AuthApiAuthUsersCreateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<User> {
      return localVarFp
        .authUsersCreate(
          requestParameters.UserCreatePasswordRetypeRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {AuthApiAuthUsersDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersDestroy(
      requestParameters: AuthApiAuthUsersDestroyRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .authUsersDestroy(requestParameters.id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {AuthApiAuthUsersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersList(
      requestParameters: AuthApiAuthUsersListRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PaginatedUserList> {
      return localVarFp
        .authUsersList(
          requestParameters.limit,
          requestParameters.offset,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersMeDestroy(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp
        .authUsersMeDestroy(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {AuthApiAuthUsersMePartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersMePartialUpdate(
      requestParameters: AuthApiAuthUsersMePartialUpdateRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<User> {
      return localVarFp
        .authUsersMePartialUpdate(requestParameters.PatchedUserRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersMeRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<User> {
      return localVarFp
        .authUsersMeRetrieve(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {AuthApiAuthUsersMeUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersMeUpdate(
      requestParameters: AuthApiAuthUsersMeUpdateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<User> {
      return localVarFp
        .authUsersMeUpdate(requestParameters.UserRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {AuthApiAuthUsersPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersPartialUpdate(
      requestParameters: AuthApiAuthUsersPartialUpdateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<User> {
      return localVarFp
        .authUsersPartialUpdate(
          requestParameters.id,
          requestParameters.PatchedUserRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {AuthApiAuthUsersResendActivationCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersResendActivationCreate(
      requestParameters: AuthApiAuthUsersResendActivationCreateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SendEmailReset> {
      return localVarFp
        .authUsersResendActivationCreate(
          requestParameters.SendEmailResetRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {AuthApiAuthUsersResetPasswordConfirmCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersResetPasswordConfirmCreate(
      requestParameters: AuthApiAuthUsersResetPasswordConfirmCreateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PasswordResetConfirmRetype> {
      return localVarFp
        .authUsersResetPasswordConfirmCreate(
          requestParameters.PasswordResetConfirmRetypeRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {AuthApiAuthUsersResetPasswordCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersResetPasswordCreate(
      requestParameters: AuthApiAuthUsersResetPasswordCreateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SendEmailReset> {
      return localVarFp
        .authUsersResetPasswordCreate(
          requestParameters.SendEmailResetRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {AuthApiAuthUsersRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersRetrieve(
      requestParameters: AuthApiAuthUsersRetrieveRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<User> {
      return localVarFp
        .authUsersRetrieve(requestParameters.id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {AuthApiAuthUsersSetPasswordCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersSetPasswordCreate(
      requestParameters: AuthApiAuthUsersSetPasswordCreateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SetPasswordRetype> {
      return localVarFp
        .authUsersSetPasswordCreate(
          requestParameters.SetPasswordRetypeRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * A version of Djoser\'s UserViewSet with some actions removed.
     * @param {AuthApiAuthUsersUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUsersUpdate(
      requestParameters: AuthApiAuthUsersUpdateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<User> {
      return localVarFp
        .authUsersUpdate(
          requestParameters.id,
          requestParameters.UserRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for authTokenLoginCreate operation in AuthApi.
 * @export
 * @interface AuthApiAuthTokenLoginCreateRequest
 */
export interface AuthApiAuthTokenLoginCreateRequest {
  /**
   *
   * @type {TokenCreateRequest}
   * @memberof AuthApiAuthTokenLoginCreate
   */
  readonly TokenCreateRequest?: TokenCreateRequest;
}

/**
 * Request parameters for authUsersActivationCreate operation in AuthApi.
 * @export
 * @interface AuthApiAuthUsersActivationCreateRequest
 */
export interface AuthApiAuthUsersActivationCreateRequest {
  /**
   *
   * @type {ActivationRequest}
   * @memberof AuthApiAuthUsersActivationCreate
   */
  readonly ActivationRequest: ActivationRequest;
}

/**
 * Request parameters for authUsersCreate operation in AuthApi.
 * @export
 * @interface AuthApiAuthUsersCreateRequest
 */
export interface AuthApiAuthUsersCreateRequest {
  /**
   *
   * @type {UserCreatePasswordRetypeRequest}
   * @memberof AuthApiAuthUsersCreate
   */
  readonly UserCreatePasswordRetypeRequest: UserCreatePasswordRetypeRequest;
}

/**
 * Request parameters for authUsersDestroy operation in AuthApi.
 * @export
 * @interface AuthApiAuthUsersDestroyRequest
 */
export interface AuthApiAuthUsersDestroyRequest {
  /**
   * A unique integer value identifying this User.
   * @type {number}
   * @memberof AuthApiAuthUsersDestroy
   */
  readonly id: number;
}

/**
 * Request parameters for authUsersList operation in AuthApi.
 * @export
 * @interface AuthApiAuthUsersListRequest
 */
export interface AuthApiAuthUsersListRequest {
  /**
   * Number of results to return per page.
   * @type {number}
   * @memberof AuthApiAuthUsersList
   */
  readonly limit?: number;

  /**
   * The initial index from which to return the results.
   * @type {number}
   * @memberof AuthApiAuthUsersList
   */
  readonly offset?: number;
}

/**
 * Request parameters for authUsersMePartialUpdate operation in AuthApi.
 * @export
 * @interface AuthApiAuthUsersMePartialUpdateRequest
 */
export interface AuthApiAuthUsersMePartialUpdateRequest {
  /**
   *
   * @type {PatchedUserRequest}
   * @memberof AuthApiAuthUsersMePartialUpdate
   */
  readonly PatchedUserRequest?: PatchedUserRequest;
}

/**
 * Request parameters for authUsersMeUpdate operation in AuthApi.
 * @export
 * @interface AuthApiAuthUsersMeUpdateRequest
 */
export interface AuthApiAuthUsersMeUpdateRequest {
  /**
   *
   * @type {UserRequest}
   * @memberof AuthApiAuthUsersMeUpdate
   */
  readonly UserRequest: UserRequest;
}

/**
 * Request parameters for authUsersPartialUpdate operation in AuthApi.
 * @export
 * @interface AuthApiAuthUsersPartialUpdateRequest
 */
export interface AuthApiAuthUsersPartialUpdateRequest {
  /**
   * A unique integer value identifying this User.
   * @type {number}
   * @memberof AuthApiAuthUsersPartialUpdate
   */
  readonly id: number;

  /**
   *
   * @type {PatchedUserRequest}
   * @memberof AuthApiAuthUsersPartialUpdate
   */
  readonly PatchedUserRequest?: PatchedUserRequest;
}

/**
 * Request parameters for authUsersResendActivationCreate operation in AuthApi.
 * @export
 * @interface AuthApiAuthUsersResendActivationCreateRequest
 */
export interface AuthApiAuthUsersResendActivationCreateRequest {
  /**
   *
   * @type {SendEmailResetRequest}
   * @memberof AuthApiAuthUsersResendActivationCreate
   */
  readonly SendEmailResetRequest: SendEmailResetRequest;
}

/**
 * Request parameters for authUsersResetPasswordConfirmCreate operation in AuthApi.
 * @export
 * @interface AuthApiAuthUsersResetPasswordConfirmCreateRequest
 */
export interface AuthApiAuthUsersResetPasswordConfirmCreateRequest {
  /**
   *
   * @type {PasswordResetConfirmRetypeRequest}
   * @memberof AuthApiAuthUsersResetPasswordConfirmCreate
   */
  readonly PasswordResetConfirmRetypeRequest: PasswordResetConfirmRetypeRequest;
}

/**
 * Request parameters for authUsersResetPasswordCreate operation in AuthApi.
 * @export
 * @interface AuthApiAuthUsersResetPasswordCreateRequest
 */
export interface AuthApiAuthUsersResetPasswordCreateRequest {
  /**
   *
   * @type {SendEmailResetRequest}
   * @memberof AuthApiAuthUsersResetPasswordCreate
   */
  readonly SendEmailResetRequest: SendEmailResetRequest;
}

/**
 * Request parameters for authUsersRetrieve operation in AuthApi.
 * @export
 * @interface AuthApiAuthUsersRetrieveRequest
 */
export interface AuthApiAuthUsersRetrieveRequest {
  /**
   * A unique integer value identifying this User.
   * @type {number}
   * @memberof AuthApiAuthUsersRetrieve
   */
  readonly id: number;
}

/**
 * Request parameters for authUsersSetPasswordCreate operation in AuthApi.
 * @export
 * @interface AuthApiAuthUsersSetPasswordCreateRequest
 */
export interface AuthApiAuthUsersSetPasswordCreateRequest {
  /**
   *
   * @type {SetPasswordRetypeRequest}
   * @memberof AuthApiAuthUsersSetPasswordCreate
   */
  readonly SetPasswordRetypeRequest: SetPasswordRetypeRequest;
}

/**
 * Request parameters for authUsersUpdate operation in AuthApi.
 * @export
 * @interface AuthApiAuthUsersUpdateRequest
 */
export interface AuthApiAuthUsersUpdateRequest {
  /**
   * A unique integer value identifying this User.
   * @type {number}
   * @memberof AuthApiAuthUsersUpdate
   */
  readonly id: number;

  /**
   *
   * @type {UserRequest}
   * @memberof AuthApiAuthUsersUpdate
   */
  readonly UserRequest: UserRequest;
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   * Use this endpoint to obtain user authentication token.
   * @param {AuthApiAuthTokenLoginCreateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authTokenLoginCreate(
    requestParameters: AuthApiAuthTokenLoginCreateRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .authTokenLoginCreate(requestParameters.TokenCreateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Use this endpoint to logout user (remove user authentication token).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authTokenLogoutCreate(options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .authTokenLogoutCreate(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * A version of Djoser\'s UserViewSet with some actions removed.
   * @param {AuthApiAuthUsersActivationCreateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authUsersActivationCreate(
    requestParameters: AuthApiAuthUsersActivationCreateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .authUsersActivationCreate(requestParameters.ActivationRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * A version of Djoser\'s UserViewSet with some actions removed.
   * @param {AuthApiAuthUsersCreateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authUsersCreate(
    requestParameters: AuthApiAuthUsersCreateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .authUsersCreate(
        requestParameters.UserCreatePasswordRetypeRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * A version of Djoser\'s UserViewSet with some actions removed.
   * @param {AuthApiAuthUsersDestroyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authUsersDestroy(
    requestParameters: AuthApiAuthUsersDestroyRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .authUsersDestroy(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * A version of Djoser\'s UserViewSet with some actions removed.
   * @param {AuthApiAuthUsersListRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authUsersList(
    requestParameters: AuthApiAuthUsersListRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .authUsersList(requestParameters.limit, requestParameters.offset, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * A version of Djoser\'s UserViewSet with some actions removed.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authUsersMeDestroy(options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .authUsersMeDestroy(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * A version of Djoser\'s UserViewSet with some actions removed.
   * @param {AuthApiAuthUsersMePartialUpdateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authUsersMePartialUpdate(
    requestParameters: AuthApiAuthUsersMePartialUpdateRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .authUsersMePartialUpdate(requestParameters.PatchedUserRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * A version of Djoser\'s UserViewSet with some actions removed.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authUsersMeRetrieve(options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .authUsersMeRetrieve(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * A version of Djoser\'s UserViewSet with some actions removed.
   * @param {AuthApiAuthUsersMeUpdateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authUsersMeUpdate(
    requestParameters: AuthApiAuthUsersMeUpdateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .authUsersMeUpdate(requestParameters.UserRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * A version of Djoser\'s UserViewSet with some actions removed.
   * @param {AuthApiAuthUsersPartialUpdateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authUsersPartialUpdate(
    requestParameters: AuthApiAuthUsersPartialUpdateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .authUsersPartialUpdate(
        requestParameters.id,
        requestParameters.PatchedUserRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * A version of Djoser\'s UserViewSet with some actions removed.
   * @param {AuthApiAuthUsersResendActivationCreateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authUsersResendActivationCreate(
    requestParameters: AuthApiAuthUsersResendActivationCreateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .authUsersResendActivationCreate(
        requestParameters.SendEmailResetRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * A version of Djoser\'s UserViewSet with some actions removed.
   * @param {AuthApiAuthUsersResetPasswordConfirmCreateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authUsersResetPasswordConfirmCreate(
    requestParameters: AuthApiAuthUsersResetPasswordConfirmCreateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .authUsersResetPasswordConfirmCreate(
        requestParameters.PasswordResetConfirmRetypeRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * A version of Djoser\'s UserViewSet with some actions removed.
   * @param {AuthApiAuthUsersResetPasswordCreateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authUsersResetPasswordCreate(
    requestParameters: AuthApiAuthUsersResetPasswordCreateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .authUsersResetPasswordCreate(
        requestParameters.SendEmailResetRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * A version of Djoser\'s UserViewSet with some actions removed.
   * @param {AuthApiAuthUsersRetrieveRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authUsersRetrieve(
    requestParameters: AuthApiAuthUsersRetrieveRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .authUsersRetrieve(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * A version of Djoser\'s UserViewSet with some actions removed.
   * @param {AuthApiAuthUsersSetPasswordCreateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authUsersSetPasswordCreate(
    requestParameters: AuthApiAuthUsersSetPasswordCreateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .authUsersSetPasswordCreate(
        requestParameters.SetPasswordRetypeRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * A version of Djoser\'s UserViewSet with some actions removed.
   * @param {AuthApiAuthUsersUpdateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authUsersUpdate(
    requestParameters: AuthApiAuthUsersUpdateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .authUsersUpdate(
        requestParameters.id,
        requestParameters.UserRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ScenesApi - axios parameter creator
 * @export
 */
export const ScenesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {SceneRequest} SceneRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scenesCreate: async (
      SceneRequest: SceneRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'SceneRequest' is not null or undefined
      assertParamExists("scenesCreate", "SceneRequest", SceneRequest);
      const localVarPath = `/v0/scenes/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication tokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "Authorization",
        configuration,
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        SceneRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scenesDestroy: async (
      key: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'key' is not null or undefined
      assertParamExists("scenesDestroy", "key", key);
      const localVarPath = `/v0/scenes/{key}/`.replace(
        `{${"key"}}`,
        encodeURIComponent(String(key)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication tokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "Authorization",
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [title]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scenesList: async (
      limit?: number,
      offset?: number,
      title?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v0/scenes/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication tokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "Authorization",
        configuration,
      );

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
      }

      if (title !== undefined) {
        localVarQueryParameter["title"] = title;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [title]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scenesMeList: async (
      limit?: number,
      offset?: number,
      title?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v0/scenes/me/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication tokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "Authorization",
        configuration,
      );

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
      }

      if (title !== undefined) {
        localVarQueryParameter["title"] = title;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} key
     * @param {PatchedSceneRequest} [PatchedSceneRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scenesPartialUpdate: async (
      key: string,
      PatchedSceneRequest?: PatchedSceneRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'key' is not null or undefined
      assertParamExists("scenesPartialUpdate", "key", key);
      const localVarPath = `/v0/scenes/{key}/`.replace(
        `{${"key"}}`,
        encodeURIComponent(String(key)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication tokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "Authorization",
        configuration,
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        PatchedSceneRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scenesRetrieve: async (
      key: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'key' is not null or undefined
      assertParamExists("scenesRetrieve", "key", key);
      const localVarPath = `/v0/scenes/{key}/`.replace(
        `{${"key"}}`,
        encodeURIComponent(String(key)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication tokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        "Authorization",
        configuration,
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ScenesApi - functional programming interface
 * @export
 */
export const ScenesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ScenesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {SceneRequest} SceneRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scenesCreate(
      SceneRequest: SceneRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scene>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scenesCreate(
        SceneRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["ScenesApi.scenesCreate"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {string} key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scenesDestroy(
      key: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scenesDestroy(
        key,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["ScenesApi.scenesDestroy"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [title]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scenesList(
      limit?: number,
      offset?: number,
      title?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PaginatedMiniSceneList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scenesList(
        limit,
        offset,
        title,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["ScenesApi.scenesList"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {string} [title]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scenesMeList(
      limit?: number,
      offset?: number,
      title?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PaginatedMiniSceneList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scenesMeList(
        limit,
        offset,
        title,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["ScenesApi.scenesMeList"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {string} key
     * @param {PatchedSceneRequest} [PatchedSceneRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scenesPartialUpdate(
      key: string,
      PatchedSceneRequest?: PatchedSceneRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scene>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.scenesPartialUpdate(
          key,
          PatchedSceneRequest,
          options,
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["ScenesApi.scenesPartialUpdate"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {string} key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scenesRetrieve(
      key: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scene>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scenesRetrieve(
        key,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap["ScenesApi.scenesRetrieve"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * ScenesApi - factory interface
 * @export
 */
export const ScenesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ScenesApiFp(configuration);
  return {
    /**
     *
     * @param {ScenesApiScenesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scenesCreate(
      requestParameters: ScenesApiScenesCreateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Scene> {
      return localVarFp
        .scenesCreate(requestParameters.SceneRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {ScenesApiScenesDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scenesDestroy(
      requestParameters: ScenesApiScenesDestroyRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .scenesDestroy(requestParameters.key, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {ScenesApiScenesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scenesList(
      requestParameters: ScenesApiScenesListRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PaginatedMiniSceneList> {
      return localVarFp
        .scenesList(
          requestParameters.limit,
          requestParameters.offset,
          requestParameters.title,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {ScenesApiScenesMeListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scenesMeList(
      requestParameters: ScenesApiScenesMeListRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PaginatedMiniSceneList> {
      return localVarFp
        .scenesMeList(
          requestParameters.limit,
          requestParameters.offset,
          requestParameters.title,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {ScenesApiScenesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scenesPartialUpdate(
      requestParameters: ScenesApiScenesPartialUpdateRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Scene> {
      return localVarFp
        .scenesPartialUpdate(
          requestParameters.key,
          requestParameters.PatchedSceneRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {ScenesApiScenesRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scenesRetrieve(
      requestParameters: ScenesApiScenesRetrieveRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Scene> {
      return localVarFp
        .scenesRetrieve(requestParameters.key, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for scenesCreate operation in ScenesApi.
 * @export
 * @interface ScenesApiScenesCreateRequest
 */
export interface ScenesApiScenesCreateRequest {
  /**
   *
   * @type {SceneRequest}
   * @memberof ScenesApiScenesCreate
   */
  readonly SceneRequest: SceneRequest;
}

/**
 * Request parameters for scenesDestroy operation in ScenesApi.
 * @export
 * @interface ScenesApiScenesDestroyRequest
 */
export interface ScenesApiScenesDestroyRequest {
  /**
   *
   * @type {string}
   * @memberof ScenesApiScenesDestroy
   */
  readonly key: string;
}

/**
 * Request parameters for scenesList operation in ScenesApi.
 * @export
 * @interface ScenesApiScenesListRequest
 */
export interface ScenesApiScenesListRequest {
  /**
   * Number of results to return per page.
   * @type {number}
   * @memberof ScenesApiScenesList
   */
  readonly limit?: number;

  /**
   * The initial index from which to return the results.
   * @type {number}
   * @memberof ScenesApiScenesList
   */
  readonly offset?: number;

  /**
   *
   * @type {string}
   * @memberof ScenesApiScenesList
   */
  readonly title?: string;
}

/**
 * Request parameters for scenesMeList operation in ScenesApi.
 * @export
 * @interface ScenesApiScenesMeListRequest
 */
export interface ScenesApiScenesMeListRequest {
  /**
   * Number of results to return per page.
   * @type {number}
   * @memberof ScenesApiScenesMeList
   */
  readonly limit?: number;

  /**
   * The initial index from which to return the results.
   * @type {number}
   * @memberof ScenesApiScenesMeList
   */
  readonly offset?: number;

  /**
   *
   * @type {string}
   * @memberof ScenesApiScenesMeList
   */
  readonly title?: string;
}

/**
 * Request parameters for scenesPartialUpdate operation in ScenesApi.
 * @export
 * @interface ScenesApiScenesPartialUpdateRequest
 */
export interface ScenesApiScenesPartialUpdateRequest {
  /**
   *
   * @type {string}
   * @memberof ScenesApiScenesPartialUpdate
   */
  readonly key: string;

  /**
   *
   * @type {PatchedSceneRequest}
   * @memberof ScenesApiScenesPartialUpdate
   */
  readonly PatchedSceneRequest?: PatchedSceneRequest;
}

/**
 * Request parameters for scenesRetrieve operation in ScenesApi.
 * @export
 * @interface ScenesApiScenesRetrieveRequest
 */
export interface ScenesApiScenesRetrieveRequest {
  /**
   *
   * @type {string}
   * @memberof ScenesApiScenesRetrieve
   */
  readonly key: string;
}

/**
 * ScenesApi - object-oriented interface
 * @export
 * @class ScenesApi
 * @extends {BaseAPI}
 */
export class ScenesApi extends BaseAPI {
  /**
   *
   * @param {ScenesApiScenesCreateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenesApi
   */
  public scenesCreate(
    requestParameters: ScenesApiScenesCreateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ScenesApiFp(this.configuration)
      .scenesCreate(requestParameters.SceneRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ScenesApiScenesDestroyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenesApi
   */
  public scenesDestroy(
    requestParameters: ScenesApiScenesDestroyRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ScenesApiFp(this.configuration)
      .scenesDestroy(requestParameters.key, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ScenesApiScenesListRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenesApi
   */
  public scenesList(
    requestParameters: ScenesApiScenesListRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return ScenesApiFp(this.configuration)
      .scenesList(
        requestParameters.limit,
        requestParameters.offset,
        requestParameters.title,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ScenesApiScenesMeListRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenesApi
   */
  public scenesMeList(
    requestParameters: ScenesApiScenesMeListRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return ScenesApiFp(this.configuration)
      .scenesMeList(
        requestParameters.limit,
        requestParameters.offset,
        requestParameters.title,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ScenesApiScenesPartialUpdateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenesApi
   */
  public scenesPartialUpdate(
    requestParameters: ScenesApiScenesPartialUpdateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ScenesApiFp(this.configuration)
      .scenesPartialUpdate(
        requestParameters.key,
        requestParameters.PatchedSceneRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ScenesApiScenesRetrieveRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScenesApi
   */
  public scenesRetrieve(
    requestParameters: ScenesApiScenesRetrieveRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ScenesApiFp(this.configuration)
      .scenesRetrieve(requestParameters.key, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
